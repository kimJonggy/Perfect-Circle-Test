import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, '..');
const CONTRACT_DIR = path.join(ROOT_DIR, 'contracts');
const NODE_MODULES = path.join(ROOT_DIR, 'node_modules');

const TARGET_FILE = 'PerfectCircleReport.sol';
const OUTPUT_FILE = 'PerfectCircleReport_flat.sol';

const processedFiles = new Set();

function resolveImport(importPath, currentDir) {
    if (importPath.startsWith('@openzeppelin')) {
        return path.join(NODE_MODULES, importPath);
    }
    return path.resolve(currentDir, importPath);
}

function processFile(filePath) {
    if (processedFiles.has(filePath)) return '';
    processedFiles.add(filePath);

    if (!fs.existsSync(filePath)) {
        console.error(`File not found: ${filePath}`);
        return `// Error: File not found ${filePath}\n`;
    }

    let content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');
    let output = '';

    const dir = path.dirname(filePath);

    for (let line of lines) {
        // Regex to capture path from:
        // import "path";
        // import { symbol } from "path";
        // import * as alias from "path";

        let matchedImport = null;

        // Match simple import "path";
        const simpleMatch = line.match(/^\s*import\s+["']([^"']+)["'];/);
        if (simpleMatch) {
            matchedImport = simpleMatch;
        } else {
            // Match from "path";
            const fromMatch = line.match(/from\s+["']([^"']+)["'];/);
            if (fromMatch) {
                matchedImport = fromMatch;
            }
        }

        if (matchedImport) {
            const importPath = matchedImport[1];
            const resolvedPath = resolveImport(importPath, dir);
            output += `// File: ${importPath}\n`;
            output += processFile(resolvedPath);
        } else {
            // Filter pragmas and SPDX
            // Strictly exclude them to avoid multiple license errors
            if (line.includes('pragma solidity') || line.includes('SPDX-License-Identifier')) {
                continue;
            } else {
                output += line + '\n';
            }
        }
    }
    return output;
}

console.log(`Flattening ${TARGET_FILE}...`);
const entryPath = path.join(CONTRACT_DIR, TARGET_FILE);
let flatContent = processFile(entryPath);

// Add header
const header = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Flattened generated by custom script
`;

const finalContent = header + flatContent;

fs.writeFileSync(path.join(CONTRACT_DIR, OUTPUT_FILE), finalContent);
console.log(`Flattened contract written to ${path.join(CONTRACT_DIR, OUTPUT_FILE)}`);
